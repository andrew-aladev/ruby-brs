<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>Ruby BRS rdoc</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>


    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="./AUTHORS.html">AUTHORS</a>
    <li><a href="./LICENSE.html">LICENSE</a>
    <li><a href="./README_md.html">README</a>
  </ul>
</div>

    <div id="classindex-section" class="nav-section">
  <h3>Class and Module Index</h3>

  <ul class="link-list">
    <li><a href="./BRS.html">BRS</a>
    <li><a href="./BRS/AccessIOError.html">BRS::AccessIOError</a>
    <li><a href="./BRS/AllocateError.html">BRS::AllocateError</a>
    <li><a href="./BRS/BaseError.html">BRS::BaseError</a>
    <li><a href="./BRS/DecompressorCorruptedSourceError.html">BRS::DecompressorCorruptedSourceError</a>
    <li><a href="./BRS/File.html">BRS::File</a>
    <li><a href="./BRS/NotEnoughDestinationBufferError.html">BRS::NotEnoughDestinationBufferError</a>
    <li><a href="./BRS/NotEnoughSourceBufferError.html">BRS::NotEnoughSourceBufferError</a>
    <li><a href="./BRS/Option.html">BRS::Option</a>
    <li><a href="./BRS/ReadIOError.html">BRS::ReadIOError</a>
    <li><a href="./BRS/Stream.html">BRS::Stream</a>
    <li><a href="./BRS/Stream/Raw.html">BRS::Stream::Raw</a>
    <li><a href="./BRS/Stream/Raw/Compressor.html">BRS::Stream::Raw::Compressor</a>
    <li><a href="./BRS/Option.html">BRS::Stream::Raw::Compressor::Option</a>
    <li><a href="./BRS/Stream/Raw/Decompressor.html">BRS::Stream::Raw::Decompressor</a>
    <li><a href="./BRS/Option.html">BRS::Stream::Raw::Decompressor::Option</a>
    <li><a href="./BRS/Stream/Reader.html">BRS::Stream::Reader</a>
    <li><a href="./BRS/Stream/Writer.html">BRS::Stream::Writer</a>
    <li><a href="./BRS/String.html">BRS::String</a>
    <li><a href="./BRS/Option.html">BRS::String::Option</a>
    <li><a href="./BRS/Validation.html">BRS::Validation</a>
    <li><a href="./BRS/WriteIOError.html">BRS::WriteIOError</a>
  </ul>
</div>

  </div>
</nav>

<main role="main">


<h1 id="label-Ruby+bindings+for+brotli+library">Ruby bindings for brotli library<span><a href="#label-Ruby+bindings+for+brotli+library">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>| AppVeyor | Jenkins | Github actions | Codecov | Gem | | :——: | :—–: | :————: | :—–: | :–: | | <a href="https://ci.appveyor.com/project/andrew-aladev/ruby-brs/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/andrew-aladev/ruby-brs?branch=master&svg=true"></a> | <a href="http://37.187.122.190:58182/job/ruby-brs"><img src="http://37.187.122.190:58182/buildStatus/icon?job=ruby-brs"></a> | <a href="https://github.com/andrew-aladev/ruby-brs/actions"><img src="https://github.com/andrew-aladev/ruby-brs/workflows/test/badge.svg?branch=master"></a> | <a href="https://codecov.io/gh/andrew-aladev/ruby-brs"><img src="https://codecov.io/gh/andrew-aladev/ruby-brs/branch/master/graph/badge.svg"></a> | <a href="https://rubygems.org/gems/ruby-brs"><img src="https://img.shields.io/gem/v/ruby-brs.svg"></a> |</p>

<p>See <a href="https://github.com/google/brotli">brotli library</a>.</p>

<p>Other bindings: <a href="https://github.com/andrew-aladev/ruby-lzws">lzw</a>, <a href="https://github.com/andrew-aladev/ruby-zstds">zstd</a>, <a href="https://github.com/andrew-aladev/ruby-bzs">bzip2</a>.</p>

<h2 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Operating systems: GNU/Linux, FreeBSD, OSX.</p>

<p>Dependencies: <a href="https://github.com/google/brotli">brotli</a> 1.0.0+ version.</p>

<table role="table">
<thead>
<tr>
<th>Popular OS</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubuntu</td>
<td>`libbrotli-dev`</td>
</tr>
<tr>
<td>CentOS</td>
<td>`brotli-devel`</td>
</tr>
<tr>
<td>ArchLinux</td>
<td>`brotli`</td>
</tr>
<tr>
<td>OSX</td>
<td>`brotli`</td>
</tr>
</tbody>
</table>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">ruby</span><span class="ruby-operator">-</span><span class="ruby-identifier">brs</span>
</pre>

<p>You can build it from source.</p>

<pre>rake gem
gem install pkg/ruby-brs-*.gem</pre>

<p>You can also use <a href="https://github.com/andrew-aladev/overlay">overlay</a> for gentoo.</p>

<h3 id="label-Installation+in+macOS+on+Apple+Silicon">Installation in macOS on Apple Silicon<span><a href="#label-Installation+in+macOS+on+Apple+Silicon">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>On M1 Macs, Homebrew installs to /opt/homebrew, so you’ll need to specify its include and lib paths when building the native extension for brotli.</p>

<pre>brew install brotli
gem install ruby-brs -- --with-opt-include=/opt/homebrew/include --with-opt-lib=/opt/homebrew/lib</pre>

<p>You can also configure Bundler to use those options when installing:</p>

<pre>bundle config set build.ruby-brs &quot;--with-opt-include=/opt/homebrew/include --with-opt-lib=/opt/homebrew/lib&quot;</pre>

<h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are simple APIs: <code>String</code> and <code>File</code>. Also you can use generic streaming API: <code>Stream::Writer</code> and <code>Stream::Reader</code>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;brs&quot;</span>

<span class="ruby-identifier">data</span> = <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">compress</span> <span class="ruby-string">&quot;sample string&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">decompress</span>(<span class="ruby-identifier">data</span>)

<span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">compress</span> <span class="ruby-string">&quot;file.txt&quot;</span>, <span class="ruby-string">&quot;file.txt.br&quot;</span>
<span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">decompress</span> <span class="ruby-string">&quot;file.txt.br&quot;</span>, <span class="ruby-string">&quot;file.txt&quot;</span>

<span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Writer</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;file.txt.br&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">writer</span><span class="ruby-operator">|</span> <span class="ruby-identifier">writer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;sample string&quot;</span> }
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;file.txt.br&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">reader</span><span class="ruby-operator">|</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read</span> }

<span class="ruby-identifier">writer</span> = <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Writer</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">output_socket</span>
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">bytes_written</span> = <span class="ruby-identifier">writer</span>.<span class="ruby-identifier">write_nonblock</span> <span class="ruby-string">&quot;sample string&quot;</span>
  <span class="ruby-comment"># handle &quot;bytes_written&quot;</span>
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitWritable</span>
  <span class="ruby-comment"># handle wait</span>
<span class="ruby-keyword">ensure</span>
  <span class="ruby-identifier">writer</span>.<span class="ruby-identifier">close</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">reader</span> = <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">input_socket</span>
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_nonblock</span>(<span class="ruby-value">512</span>)
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitReadable</span>
  <span class="ruby-comment"># handle wait</span>
<span class="ruby-keyword">rescue</span> <span class="ruby-operator">::</span><span class="ruby-constant">EOFError</span>
  <span class="ruby-comment"># handle eof</span>
<span class="ruby-keyword">ensure</span>
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">close</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can create and read <code>tar.br</code> archives with <a href="https://github.com/halostatue/minitar">minitar</a>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;brs&quot;</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;minitar&quot;</span>

<span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Writer</span>.<span class="ruby-identifier">open</span> <span class="ruby-string">&quot;file.tar.br&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">writer</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">Minitar</span><span class="ruby-operator">::</span><span class="ruby-constant">Writer</span>.<span class="ruby-identifier">open</span> <span class="ruby-identifier">writer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tar</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">tar</span>.<span class="ruby-identifier">add_file_simple</span> <span class="ruby-string">&quot;file&quot;</span>, <span class="ruby-value">:data</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;sample string&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">Stream</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">open</span> <span class="ruby-string">&quot;file.tar.br&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">reader</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">Minitar</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">open</span> <span class="ruby-identifier">reader</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tar</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">tar</span>.<span class="ruby-identifier">each_entry</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">entry</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-identifier">entry</span>.<span class="ruby-identifier">name</span>
      <span class="ruby-identifier">puts</span> <span class="ruby-identifier">entry</span>.<span class="ruby-identifier">read</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can also use <code>Content-Encoding: br</code> with <a href="http://sinatrarb.com">sinatra</a>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;brs&quot;</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;sinatra&quot;</span>

<span class="ruby-identifier">get</span> <span class="ruby-string">&quot;/&quot;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">headers</span>[<span class="ruby-string">&quot;Content-Encoding&quot;</span>] = <span class="ruby-string">&quot;br&quot;</span>
  <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">compress</span> <span class="ruby-string">&quot;sample string&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>All functionality (including streaming) can be used inside multiple threads with <a href="https://github.com/grosser/parallel">parallel</a>. This code will provide heavy load for your CPU.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;brs&quot;</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;parallel&quot;</span>

<span class="ruby-constant">Parallel</span>.<span class="ruby-identifier">each</span> <span class="ruby-identifier">large_datas</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">large_data</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">compress</span> <span class="ruby-identifier">large_data</span>
<span class="ruby-keyword">end</span>
</pre>

<h1 id="label-Docs">Docs<span><a href="#label-Docs">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Please review <a href="https://andrew-aladev.github.io/ruby-brs">rdoc generated docs</a>.</p>

<h2 id="label-Options">Options<span><a href="#label-Options">&para;</a> <a href="#top">&uarr;</a></span></h2>

<table role="table">
<thead>
<tr>
<th>Option</th>
<th>Values</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`source_buffer_length`</td>
<td>0 - inf</td>
<td>0 (auto)</td>
<td>internal buffer length for source data</td>
</tr>
<tr>
<td>`destination_buffer_length`</td>
<td>0 - inf</td>
<td>0 (auto)</td>
<td>internal buffer length for description data</td>
</tr>
<tr>
<td>`gvl`</td>
<td>true/false</td>
<td>false</td>
<td>enables global VM lock where possible</td>
</tr>
<tr>
<td>`mode`</td>
<td>`MODES`</td>
<td>`:generic`</td>
<td>compressor mode</td>
</tr>
<tr>
<td>`quality`</td>
<td>0 - 11</td>
<td>11</td>
<td>compression level</td>
</tr>
<tr>
<td>`lgwin`</td>
<td>10 - 24</td>
<td>22</td>
<td>compressor window size</td>
</tr>
<tr>
<td>`lgblock`</td>
<td>16 - 24</td>
<td>nil (auto)</td>
<td>compressor input block size</td>
</tr>
<tr>
<td>`npostfix`</td>
<td>0 - 3</td>
<td>nil (auto)</td>
<td>recommended number of postfix bits</td>
</tr>
<tr>
<td>`ndirect`</td>
<td>0 - 120</td>
<td>nil (auto)</td>
<td>recommended number of direct distance codes (step 1 &lt;&lt; npostfix, max 15 &lt;&lt; npostfix)</td>
</tr>
<tr>
<td>`disable_literal_context_modeling`</td>
<td>true/false</td>
<td>false</td>
<td>disables literal context modeling format</td>
</tr>
<tr>
<td>`disable_ring_buffer_reallocation`</td>
<td>true/false</td>
<td>false</td>
<td>disables ring buffer reallocation</td>
</tr>
<tr>
<td>`size_hint`</td>
<td>0 - inf</td>
<td>0 (auto)</td>
<td>size of input (if known)</td>
</tr>
<tr>
<td>`large_window`</td>
<td>true/false</td>
<td>false</td>
<td>enables large window</td>
</tr>
</tbody>
</table>

<p>There are internal buffers for compressed and decompressed data. For example you want to use 1 KB as <code>source_buffer_length</code> for compressor - please use 256 B as <code>destination_buffer_length</code>. You want to use 256 B as <code>source_buffer_length</code> for decompressor - please use 1 KB as <code>destination_buffer_length</code>.</p>

<p><code>gvl</code> is disabled by default, this mode allows running multiple compressors/decompressors in different threads simultaneously. Please consider enabling <code>gvl</code> if you don’t want to launch processors in separate threads. If <code>gvl</code> is enabled ruby won’t waste time on acquiring/releasing VM lock.</p>

<p><code>String</code> and <code>File</code> will set <code>:size_hint</code> automaticaly.</p>

<p>You can also read brotli docs for more info about options.</p>

<table role="table">
<thead>
<tr>
<th>Option</th>
<th>Related constants</th>
</tr>
</thead>
<tbody>
<tr>
<td>`mode`</td>
<td>`BRS::Option::MODES` = `%i[text font generic]`</td>
</tr>
<tr>
<td>`quality`</td>
<td>`BRS::Option::MIN_QUALITY` = 0, `BRS::Option::MAX_QUALITY` = 11</td>
</tr>
<tr>
<td>`lgwin`</td>
<td>`BRS::Option::MIN_LGWIN` = 10, `BRS::Option::MAX_LGWIN` = 24</td>
</tr>
<tr>
<td>`lgblock`</td>
<td>`BRS::Option::MIN_LGBLOCK` = 16, `BRS::Option::MAX_LGBLOCK` = 24</td>
</tr>
<tr>
<td>`npostfix`</td>
<td>`BRS::Option::MIN_NPOSTFIX` = 0, `BRS::Option::MAX_NPOSTFIX` = 3</td>
</tr>
<tr>
<td>`ndirect`</td>
<td>`BRS::Option::MIN_NDIRECT` = 0, `BRS::Option::MAX_NDIRECT` = 120, `BRS::Option::NDIRECT_NPOSTFIX_STEP_BASE` = 1, `BRS::Option::NDIRECT_NPOSTFIX_MAX_BASE` = 15</td>
</tr>
</tbody>
</table>

<p>Possible compressor options:</p>

<pre class="ruby"><span class="ruby-value">:source_buffer_length</span>
<span class="ruby-value">:destination_buffer_length</span>
<span class="ruby-value">:gvl</span>
<span class="ruby-value">:mode</span>
<span class="ruby-value">:quality</span>
<span class="ruby-value">:lgwin</span>
<span class="ruby-value">:lgblock</span>
<span class="ruby-value">:npostfix</span>
<span class="ruby-value">:ndirect</span>
<span class="ruby-value">:disable_literal_context_modeling</span>
<span class="ruby-value">:size_hint</span>
<span class="ruby-value">:large_window</span>
</pre>

<p>Possible decompressor options:</p>

<pre class="ruby"><span class="ruby-value">:source_buffer_length</span>
<span class="ruby-value">:destination_buffer_length</span>
<span class="ruby-value">:gvl</span>
<span class="ruby-value">:disable_ring_buffer_reallocation</span>
<span class="ruby-value">:large_window</span>
</pre>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;brs&quot;</span>

<span class="ruby-identifier">data</span> = <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">compress</span> <span class="ruby-string">&quot;sample string&quot;</span>, <span class="ruby-value">:quality</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">5</span>
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BRS</span><span class="ruby-operator">::</span><span class="ruby-constant">String</span>.<span class="ruby-identifier">decompress</span>(<span class="ruby-identifier">data</span>, <span class="ruby-value">:disable_ring_buffer_reallocation</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">true</span>)
</pre>

<h2 id="label-String">String<span><a href="#label-String">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>String maintains destination buffer only, so it accepts <code>destination_buffer_length</code> option only.</p>

<pre>::compress(source, options = {})
::decompress(source, options = {})</pre>

<p><code>source</code> is a source string.</p>

<h2 id="label-File">File<span><a href="#label-File">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>File maintains both source and destination buffers, it accepts both <code>source_buffer_length</code> and <code>destination_buffer_length</code> options.</p>

<pre>::compress(source, destination, options = {})
::decompress(source, destination, options = {})</pre>

<p><code>source</code> and <code>destination</code> are file pathes.</p>

<h2 id="label-Stream-3A-3AWriter">Stream::Writer<span><a href="#label-Stream-3A-3AWriter">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Its behaviour is similar to builtin {<code>Zlib::GzipWriter</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipWriter.html">}</a>.</p>

<p>Writer maintains destination buffer only, so it accepts <code>destination_buffer_length</code> option only.</p>

<pre>::open(file_path, options = {}, :external_encoding =&gt; nil, :transcode_options =&gt; {}, &amp;block)</pre>

<p>Open file path and create stream writer associated with opened file. Data will be transcoded to <code>:external_encoding</code> using <code>:transcode_options</code> before compressing.</p>

<p>It may be tricky to use both <code>:size_hint</code> and <code>:transcode_options</code>. You have to provide size of transcoded input.</p>

<pre>::new(destination_io, options = {}, :external_encoding =&gt; nil, :transcode_options =&gt; {})</pre>

<p>Create stream writer associated with destination io. Data will be transcoded to <code>:external_encoding</code> using <code>:transcode_options</code> before compressing.</p>

<p>It may be tricky to use both <code>:size_hint</code> and <code>:transcode_options</code>. You have to provide size of transcoded input.</p>

<pre class="ruby"><span class="ruby-comment">#set_encoding(external_encoding, nil, transcode_options)</span>
</pre>

<p>Set another encodings, <code>nil</code> is just for compatibility with <code>IO</code>.</p>

<pre class="ruby"><span class="ruby-comment">#io</span>
<span class="ruby-comment">#to_io</span>
<span class="ruby-comment">#stat</span>
<span class="ruby-comment">#external_encoding</span>
<span class="ruby-comment">#transcode_options</span>
<span class="ruby-comment">#pos</span>
<span class="ruby-comment">#tell</span>
</pre>

<p>See {<code>IO</code><a href="https://ruby-doc.org/core/IO.html">}</a> docs.</p>

<pre class="ruby"><span class="ruby-comment">#write(*objects)</span>
<span class="ruby-comment">#flush</span>
<span class="ruby-comment">#rewind</span>
<span class="ruby-comment">#close</span>
<span class="ruby-comment">#closed?</span>
</pre>

<p>See {<code>Zlib::GzipWriter</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipWriter.html">}</a> docs.</p>

<pre class="ruby"><span class="ruby-comment">#write_nonblock(object, *options)</span>
<span class="ruby-comment">#flush_nonblock(*options)</span>
<span class="ruby-comment">#rewind_nonblock(*options)</span>
<span class="ruby-comment">#close_nonblock(*options)</span>
</pre>

<p>Special asynchronous methods missing in <code>Zlib::GzipWriter</code>. <code>rewind</code> wants to <code>close</code>, <code>close</code> wants to <code>write</code> something and <code>flush</code>, <code>flush</code> want to <code>write</code> something. So it is possible to have asynchronous variants for these synchronous methods. Behaviour is the same as <code>IO#write_nonblock</code> method.</p>

<pre class="ruby"><span class="ruby-comment">#&lt;&lt;(object)</span>
<span class="ruby-comment">#print(*objects)</span>
<span class="ruby-comment">#printf(*args)</span>
<span class="ruby-comment">#putc(object, :encoding =&gt; &#39;ASCII-8BIT&#39;)</span>
<span class="ruby-comment">#puts(*objects)</span>
</pre>

<p>Typical helpers, see {<code>Zlib::GzipWriter</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipWriter.html">}</a> docs.</p>

<h2 id="label-Stream-3A-3AReader">Stream::Reader<span><a href="#label-Stream-3A-3AReader">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Its behaviour is similar to builtin {<code>Zlib::GzipReader</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipReader.html">}</a>.</p>

<p>Reader maintains both source and destination buffers, it accepts both <code>source_buffer_length</code> and <code>destination_buffer_length</code> options.</p>

<pre>::open(file_path, options = {}, :external_encoding =&gt; nil, :internal_encoding =&gt; nil, :transcode_options =&gt; {}, &amp;block)</pre>

<p>Open file path and create stream reader associated with opened file. Data will be force encoded to <code>:external_encoding</code> and transcoded to <code>:internal_encoding</code> using <code>:transcode_options</code> after decompressing.</p>

<pre>::new(source_io, options = {}, :external_encoding =&gt; nil, :internal_encoding =&gt; nil, :transcode_options =&gt; {})</pre>

<p>Create stream reader associated with source io. Data will be force encoded to <code>:external_encoding</code> and transcoded to <code>:internal_encoding</code> using <code>:transcode_options</code> after decompressing.</p>

<pre class="ruby"><span class="ruby-comment">#set_encoding(external_encoding, internal_encoding, transcode_options)</span>
</pre>

<p>Set another encodings.</p>

<pre class="ruby"><span class="ruby-comment">#io</span>
<span class="ruby-comment">#to_io</span>
<span class="ruby-comment">#stat</span>
<span class="ruby-comment">#external_encoding</span>
<span class="ruby-comment">#internal_encoding</span>
<span class="ruby-comment">#transcode_options</span>
<span class="ruby-comment">#pos</span>
<span class="ruby-comment">#tell</span>
</pre>

<p>See {<code>IO</code><a href="https://ruby-doc.org/core/IO.html">}</a> docs.</p>

<pre class="ruby"><span class="ruby-comment">#read(bytes_to_read = nil, out_buffer = nil)</span>
<span class="ruby-comment">#eof?</span>
<span class="ruby-comment">#rewind</span>
<span class="ruby-comment">#close</span>
<span class="ruby-comment">#closed?</span>
</pre>

<p>See {<code>Zlib::GzipReader</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipReader.html">}</a> docs.</p>

<pre class="ruby"><span class="ruby-comment">#readpartial(bytes_to_read = nil, out_buffer = nil)</span>
<span class="ruby-comment">#read_nonblock(bytes_to_read, out_buffer = nil, *options)</span>
</pre>

<p>See {<code>IO</code><a href="https://ruby-doc.org/core/IO.html">}</a> docs.</p>

<pre class="ruby"><span class="ruby-comment">#getbyte</span>
<span class="ruby-comment">#each_byte(&amp;block)</span>
<span class="ruby-comment">#readbyte</span>
<span class="ruby-comment">#ungetbyte(byte)</span>

<span class="ruby-comment">#getc</span>
<span class="ruby-comment">#readchar</span>
<span class="ruby-comment">#each_char(&amp;block)</span>
<span class="ruby-comment">#ungetc(char)</span>

<span class="ruby-comment">#lineno</span>
<span class="ruby-comment">#lineno=</span>
<span class="ruby-comment">#gets(separator = $OUTPUT_RECORD_SEPARATOR, limit = nil)</span>
<span class="ruby-comment">#readline</span>
<span class="ruby-comment">#readlines</span>
<span class="ruby-comment">#each(&amp;block)</span>
<span class="ruby-comment">#each_line(&amp;block)</span>
<span class="ruby-comment">#ungetline(line)</span>
</pre>

<p>Typical helpers, see {<code>Zlib::GzipReader</code><a href="https://ruby-doc.org/stdlib/libdoc/zlib/rdoc/Zlib/GzipReader.html">}</a> docs.</p>

<h2 id="label-Thread+safety">Thread safety<span><a href="#label-Thread+safety">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><code>:gvl</code> option is disabled by default, you can use bindings effectively in multiple threads. Please be careful: bindings are not thread safe. You should lock all shared data between threads.</p>

<p>For example: you should not use same compressor/decompressor inside multiple threads. Please verify that you are using each processor inside single thread at the same time.</p>

<h2 id="label-CI">CI<span><a href="#label-CI">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Please visit <a href="scripts/test-images">scripts/test-images</a>. See universal test script <a href="scripts/ci_test.sh">scripts/ci_test.sh</a> for CI.</p>

<h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>MIT license, see <a href="LICENSE">LICENSE</a> and <a href="AUTHORS">AUTHORS</a>.</p>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

